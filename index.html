<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>JIANG HAO</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="JIANG HAO">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="JIANG HAO">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JIANG HAO">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="JIANG HAO" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">JIANG HAO</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-android广播使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/11/21/android广播使用/" class="article-date">
  <time datetime="2015-11-21T03:44:26.000Z" itemprop="datePublished">2015-11-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/21/android广播使用/">android广播的使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>BroadcastReceiver也就是“广播接收者”的意思，顾名思义，它就是用来接收来自系统和应用中的广播。<br>在Android系统中，广播体现在方方面面，例如当开机完成后系统会产生一条广播，接收到这条广播就能实现开机启动服务的功能；当网络状态改变时系统会产生一条广播，接收到这条广播就能及时地做出提示和保存数据等操作；当电池电量改变时，系统会产生一条广播，接收到这条广播就能在电量低时告知用户及时保存进度，等等。<br>Android中的广播机制设计的非常出色，很多事情原本需要开发者亲自操作的，现在只需等待广播告知自己就可以了，大大减少了开发的工作量和开发周期。而作为应用开发者，就需要数练掌握Android系统提供的一个开发利器，那就是BroadcastReceiver。下面我们就对BroadcastReceiver逐一地分析和演练，了解和掌握它的各种功能和用法。</p>
<p>.首先，我们来演示一下创建一个BroadcastReceiver，并让这个BroadcastReceiver能够根据我们的需要来运行。要创建自己的BroadcastReceiver对象，我们需要继承android.content.BroadcastReceiver，并实现其onReceive方法。下面我们就创建一个名为MyReceiver广播接收者：<br>package com.scott.receiver;  </p>
<p>import android.content.BroadcastReceiver;<br>import android.content.Context;<br>import android.content.Intent;<br>import android.util.Log;  </p>
<p>public class MyReceiver extends BroadcastReceiver {  </p>
<pre><code><span class="keyword">private</span> static final <span class="built_in">String</span> <span class="built_in">TAG</span> = <span class="string">"MyReceiver"</span>;  

@Override  
<span class="keyword">public</span> <span class="literal">void</span> onReceive(Context context, Intent intent) {  
    <span class="built_in">String</span> msg = intent<span class="built_in">.</span>getStringExtra(<span class="string">"msg"</span>);  
    <span class="keyword">Log</span><span class="built_in">.</span>i(<span class="built_in">TAG</span>, msg);  
}  
</code></pre><p>}<br>.在onReceive方法内，我们可以获取随广播而来的Intent中的数据，这非常重要，就像无线电一样，包含很多有用的信息。<br>在创建完我们的BroadcastReceiver之后，还不能够使它进入工作状态，我们需要为它注册一个指定的广播地址。没有注册广播地址的BroadcastReceiver就像一个缺少选台按钮的收音机，虽然功能俱备，但也无法收到电台的信号。下面我们就来介绍一下如何为BroadcastReceiver注册广播地址。</p>
<p>##静态注册<br>.静态注册是在AndroidManifest.xml文件中配置的，我们就来为MyReceiver注册一个广播地址：<br>[html] view plaincopy</p>
<p><receiver android:name=".MyReceiver"><br>            <intent-filter><br>                <action android:name="android.intent.action.MY_BROADCAST"><br>                <category android:name="android.intent.category.DEFAULT"><br>            </category></action></intent-filter><br>        </receiver><br>配置了以上信息之后，只要是android.intent.action.MY_BROADCAST这个地址的广播，MyReceiver都能够接收的到。注意，这种方式的注册是常驻型的，也就是说当应用关闭后，如果有广播信息传来，MyReceiver也会被系统调用而自动运行。</p>
<p>##动态注册<br>.动态注册需要在代码中动态的指定广播地址并注册，通常我们是在Activity或Service注册一个广播，下面我们就来看一下注册的代码：<br>[java] view plaincopy<br>MyReceiver receiver = new MyReceiver();  </p>
<p>IntentFilter filter = new IntentFilter();<br>filter.addAction(“android.intent.action.MY_BROADCAST”);  </p>
<p>registerReceiver(receiver, filter);<br>注意，registerReceiver是android.content.ContextWrapper类中的方法，Activity和Service都继承了ContextWrapper，所以可以直接调用。在实际应用中，我们在Activity或Service中注册了一个BroadcastReceiver，当这个Activity或Service被销毁时如果没有解除注册，系统会报一个异常，提示我们是否忘记解除注册了。所以，记得在特定的地方执行解除注册操作：<br>[java] view plaincopy<br>@Override<br>protected void onDestroy() {<br>    super.onDestroy();<br>    unregisterReceiver(receiver);<br>}<br>执行这样行代码就可以解决问题了。注意，这种注册方式与静态注册相反，不是常驻型的，也就是说广播会跟随程序的生命周期。<br>我们可以根据以上任意一种方法完成注册，当注册完成之后，这个接收者就可以正常工作了。我们可以用以下方式向其发送一条广播：<br>[java] view plaincopy<br>public void send(View view) {<br>    Intent intent = new Intent(“android.intent.action.MY_BROADCAST”);<br>    intent.putExtra(“msg”, “hello receiver.”);<br>    sendBroadcast(intent);<br>}<br>注意，sendBroadcast也是android.content.ContextWrapper类中的方法，它可以将一个指定地址和参数信息的Intent对象以广播的形式发送出去。<br>点击发送按钮，执行send方法，控制台打印如下：</p>
<p>看到这样的打印信息，表明我们的广播已经发出去了，并且被MyReceiver准确无误的接收到了。<br>上面的例子只是一个接收者来接收广播，如果有多个接收者都注册了相同的广播地址，又会是什么情况呢，能同时接收到同一条广播吗，相互之间会不会有干扰呢？这就涉及到普通广播和有序广播的概念了。</p>
<p>##普通广播（Normal Broadcast）<br>普通广播对于多个接收者来说是完全异步的，通常每个接收者都无需等待即可以接收到广播，接收者相互之间不会有影响。对于这种广播，接收者无法终止广播，即无法阻止其他接收者的接收动作。<br>为了验证以上论断，我们新建三个BroadcastReceiver，演示一下这个过程，FirstReceiver、SecondReceiver和ThirdReceiver的代码如下：<br>[java] view plaincopy<br>package com.scott.receiver;  </p>
<p>import android.content.BroadcastReceiver;<br>import android.content.Context;<br>import android.content.Intent;<br>import android.util.Log;  </p>
<p>public class FirstReceiver extends BroadcastReceiver {  </p>
<pre><code><span class="keyword">private</span> static final <span class="built_in">String</span> <span class="built_in">TAG</span> = <span class="string">"NormalBroadcast"</span>;  

@Override  
<span class="keyword">public</span> <span class="literal">void</span> onReceive(Context context, Intent intent) {  
    <span class="built_in">String</span> msg = intent<span class="built_in">.</span>getStringExtra(<span class="string">"msg"</span>);  
    <span class="keyword">Log</span><span class="built_in">.</span>i(<span class="built_in">TAG</span>, <span class="string">"FirstReceiver: "</span> + msg);  
}  
</code></pre><p>}<br>[java] view plaincopy<br>public class SecondReceiver extends BroadcastReceiver {  </p>
<pre><code><span class="keyword">private</span> static final <span class="built_in">String</span> <span class="built_in">TAG</span> = <span class="string">"NormalBroadcast"</span>;  

@Override  
<span class="keyword">public</span> <span class="literal">void</span> onReceive(Context context, Intent intent) {  
    <span class="built_in">String</span> msg = intent<span class="built_in">.</span>getStringExtra(<span class="string">"msg"</span>);  
    <span class="keyword">Log</span><span class="built_in">.</span>i(<span class="built_in">TAG</span>, <span class="string">"SecondReceiver: "</span> + msg);  
}  
</code></pre><p>}<br>[java] view plaincopy<br>public class ThirdReceiver extends BroadcastReceiver {  </p>
<pre><code><span class="keyword">private</span> static final <span class="built_in">String</span> <span class="built_in">TAG</span> = <span class="string">"NormalBroadcast"</span>;  

@Override  
<span class="keyword">public</span> <span class="literal">void</span> onReceive(Context context, Intent intent) {  
    <span class="built_in">String</span> msg = intent<span class="built_in">.</span>getStringExtra(<span class="string">"msg"</span>);  
    <span class="keyword">Log</span><span class="built_in">.</span>i(<span class="built_in">TAG</span>, <span class="string">"ThirdReceiver: "</span> + msg);  
}  
</code></pre><p>}<br>然后再次点击发送按钮，发送一条广播，控制台打印如下：</p>
<p>看来这三个接收者都接收到这条广播了，我们稍微修改一下三个接收者，在onReceive方法的最后一行添加以下代码，试图终止广播：<br>[java] view plaincopy<br>abortBroadcast();<br>再次点击发送按钮，我们会发现，控制台中三个接收者仍然都打印了自己的日志，表明接收者并不能终止广播。<br>有序广播（Ordered Broadcast）<br>有序广播比较特殊，它每次只发送到优先级较高的接收者那里，然后由优先级高的接受者再传播到优先级低的接收者那里，优先级高的接收者有能力终止这个广播。<br>为了演示有序广播的流程，我们修改一下上面三个接收者的代码，如下：<br>[java] view plaincopy<br>package com.scott.receiver;  </p>
<p>import android.content.BroadcastReceiver;<br>import android.content.Context;<br>import android.content.Intent;<br>import android.os.Bundle;<br>import android.util.Log;  </p>
<p>public class FirstReceiver extends BroadcastReceiver {  </p>
<pre><code><span class="keyword">private</span> static final <span class="built_in">String</span> <span class="built_in">TAG</span> = <span class="string">"OrderedBroadcast"</span>;  

@Override  
<span class="keyword">public</span> <span class="literal">void</span> onReceive(Context context, Intent intent) {  
    <span class="built_in">String</span> msg = intent<span class="built_in">.</span>getStringExtra(<span class="string">"msg"</span>);  
    <span class="keyword">Log</span><span class="built_in">.</span>i(<span class="built_in">TAG</span>, <span class="string">"FirstReceiver: "</span> + msg);  

    Bundle bundle = <span class="literal">new</span> Bundle();  
    bundle<span class="built_in">.</span>putString(<span class="string">"msg"</span>, msg + <span class="string">"@FirstReceiver"</span>);  
    setResultExtras(bundle);  
}  
</code></pre><p>}<br>[java] view plaincopy<br>public class SecondReceiver extends BroadcastReceiver {  </p>
<pre><code><span class="keyword">private</span> static final <span class="built_in">String</span> <span class="built_in">TAG</span> = <span class="string">"OrderedBroadcast"</span>;  

@Override  
<span class="keyword">public</span> <span class="literal">void</span> onReceive(Context context, Intent intent) {  
    <span class="built_in">String</span> msg = getResultExtras(<span class="literal">true</span>)<span class="built_in">.</span>getString(<span class="string">"msg"</span>);  
    <span class="keyword">Log</span><span class="built_in">.</span>i(<span class="built_in">TAG</span>, <span class="string">"SecondReceiver: "</span> + msg);  

    Bundle bundle = <span class="literal">new</span> Bundle();  
    bundle<span class="built_in">.</span>putString(<span class="string">"msg"</span>, msg + <span class="string">"@SecondReceiver"</span>);  
    setResultExtras(bundle);  
}  
</code></pre><p>}<br>[java] view plaincopy<br>public class ThirdReceiver extends BroadcastReceiver {  </p>
<pre><code><span class="keyword">private</span> static final <span class="built_in">String</span> <span class="built_in">TAG</span> = <span class="string">"OrderedBroadcast"</span>;  

@Override  
<span class="keyword">public</span> <span class="literal">void</span> onReceive(Context context, Intent intent) {  
    <span class="built_in">String</span> msg = getResultExtras(<span class="literal">true</span>)<span class="built_in">.</span>getString(<span class="string">"msg"</span>);  
    <span class="keyword">Log</span><span class="built_in">.</span>i(<span class="built_in">TAG</span>, <span class="string">"ThirdReceiver: "</span> + msg);  
}  
</code></pre><p>}<br>我们注意到，在FirstReceiver和SecondReceiver中最后都使用了setResultExtras方法将一个Bundle对象设置为结果集对象，传递到下一个接收者那里，这样以来，优先级低的接收者可以用getResultExtras获取到最新的经过处理的信息集合。<br>代码改完之后，我们需要为三个接收者注册广播地址，我们修改一下AndroidMainfest.xml文件：<br>[html] view plaincopy</p>
<p><receiver android:name=".FirstReceiver"><br>    <intent-filter android:priority="1000"><br>        <action android:name="android.intent.action.MY_BROADCAST"><br>        <category android:name="android.intent.category.DEFAULT"><br>    </category></action></intent-filter><br></receiver>  </p>
<p><receiver android:name=".SecondReceiver"><br>    <intent-filter android:priority="999"><br>        <action android:name="android.intent.action.MY_BROADCAST"><br>        <category android:name="android.intent.category.DEFAULT"><br>    </category></action></intent-filter><br></receiver>  </p>
<p><receiver android:name=".ThirdReceiver"><br>    <intent-filter android:priority="998"><br>        <action android:name="android.intent.action.MY_BROADCAST"><br>        <category android:name="android.intent.category.DEFAULT"><br>    </category></action></intent-filter><br></receiver><br>我们看到，现在这三个接收者的<intent-filter>多了一个android:priority属性，并且依次减小。这个属性的范围在-1000到1000，数值越大，优先级越高。<br>现在，我们需要修改一下发送广播的代码，如下：<br>[java] view plaincopy<br>public void send(View view) {<br>    Intent intent = new Intent(“android.intent.action.MY_BROADCAST”);<br>    intent.putExtra(“msg”, “hello receiver.”);<br>    sendOrderedBroadcast(intent, “scott.permission.MY_BROADCAST_PERMISSION”);<br>}<br>注意，使用sendOrderedBroadcast方法发送有序广播时，需要一个权限参数，如果为null则表示不要求接收者声明指定的权限，如果不为null，则表示接收者若要接收此广播，需声明指定权限。这样做是从安全角度考虑的，例如系统的短信就是有序广播的形式，一个应用可能是具有拦截垃圾短信的功能，当短信到来时它可以先接受到短信广播，必要时终止广播传递，这样的软件就必须声明接收短信的权限。<br>所以我们在AndroidMainfest.xml中定义一个权限：<br>[html] view plaincopy</intent-filter></p>
<p><permission android:protectionlevel="normal" android:name="scott.permission.MY_BROADCAST_PERMISSION"><br>然后声明使用了此权限：<br>[html] view plaincopy</permission></p>
<p><uses-permission android:name="scott.permission.MY_BROADCAST_PERMISSION"><br>关于这部分如果有不明白的地方可以参考我之前写过的一篇文章：Android声明和使用权限<br>然后我们点击发送按钮发送一条广播，控制台打印如下：</uses-permission></p>
<p>我们看到接收是按照顺序的，第一个和第二个都在结果集中加入了自己的标记，并且向优先级低的接收者传递下去。<br>既然是顺序传递，试着终止这种传递，看一看效果如何，我们修改FirstReceiver的代码，在onReceive的最后一行添加以下代码：<br>[java] view plaincopy<br>abortBroadcast();<br>然后再次运行程序，控制台打印如下：</p>
<p>此次，只有第一个接收者执行了，其它两个都没能执行，因为广播被第一个接收者终止了。<br>上面就是BroadcastReceiver的介绍，下面我将会举几个常见的例子加深一下大家对广播的理解和应用：<br>1.开机启动服务<br>我们经常会有这样的应用场合，比如消息推送服务，需要实现开机启动的功能。要实现这个功能，我们就可以订阅系统“启动完成”这条广播，接收到这条广播后我们就可以启动自己的服务了。我们来看一下BootCompleteReceiver和MsgPushService的具体实现：<br>[java] view plaincopy<br>package com.scott.receiver;  </p>
<p>import android.content.BroadcastReceiver;<br>import android.content.Context;<br>import android.content.Intent;<br>import android.util.Log;  </p>
<p>public class BootCompleteReceiver extends BroadcastReceiver {  </p>
<pre><code><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"BootCompleteReceiver"</span>;  

<span class="annotation">@Override</span>  
<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>{  
    Intent service = <span class="keyword">new</span> Intent(context, MsgPushService.class);  
    context.startService(service);  
    Log.i(TAG, <span class="string">"Boot Complete. Starting MsgPushService..."</span>);  
}  
</code></pre><p>}<br>[java] view plaincopy<br>package com.scott.receiver;  </p>
<p>import android.app.Service;<br>import android.content.Intent;<br>import android.os.IBinder;<br>import android.util.Log;  </p>
<p>public class MsgPushService extends Service {  </p>
<pre><code><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MsgPushService"</span>;  

<span class="annotation">@Override</span>  
<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>{  
    <span class="keyword">super</span>.onCreate();  
    Log.i(TAG, <span class="string">"onCreate called."</span>);  
}  

<span class="annotation">@Override</span>  
<span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>{  
    Log.i(TAG, <span class="string">"onStartCommand called."</span>);  
    <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">onStartCommand</span><span class="params">(intent, flags, startId)</span></span>;  
}  

<span class="annotation">@Override</span>  
<span class="keyword">public</span> <span class="function">IBinder <span class="title">onBind</span><span class="params">(Intent arg0)</span> </span>{  
    <span class="keyword">return</span> <span class="keyword">null</span>;  
}  
</code></pre><p>}<br>然后我们需要在AndroidManifest.xml中配置相关信息：<br>[html] view plaincopy<br><!-- 开机广播接受者 -->  </p>
<p><receiver android:name=".BootCompleteReceiver"><br>    <intent-filter><br>        <!-- 注册开机广播地址--><br>        <action android:name="android.intent.action.BOOT_COMPLETED"><br>        <category android:name="android.intent.category.DEFAULT"><br>    </category></action></intent-filter><br></receiver><br><!-- 消息推送服务 -->  </p>
<p><service android:name=".MsgPushService"><br>我们看到BootCompleteReceiver注册了“android.intent.action.BOOT_COMPLETED”这个开机广播地址，从安全角度考虑，系统要求必须声明接收开机启动广播的权限，于是我们再声明使用下面的权限：<br>[html] view plaincopy</service></p>
<p><uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"><br>经过上面的几个步骤之后，我们就完成了开机启动的功能，将应用运行在模拟器上，然后重启模拟器，控制台打印如下：</uses-permission></p>
<p>如果我们查看已运行的服务就会发现，MsgPushService已经运行起来了。<br>2.网络状态变化<br>在某些场合，比如用户浏览网络信息时，网络突然断开，我们要及时地提醒用户网络已断开。要实现这个功能，我们可以接收网络状态改变这样一条广播，当由连接状态变为断开状态时，系统就会发送一条广播，我们接收到之后，再通过网络的状态做出相应的操作。下面就来实现一下这个功能：<br>[java] view plaincopy<br>package com.scott.receiver;  </p>
<p>import android.content.BroadcastReceiver;<br>import android.content.Context;<br>import android.content.Intent;<br>import android.net.ConnectivityManager;<br>import android.net.NetworkInfo;<br>import android.util.Log;<br>import android.widget.Toast;  </p>
<p>public class NetworkStateReceiver extends BroadcastReceiver {  </p>
<pre><code><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"NetworkStateReceiver"</span>;  

<span class="annotation">@Override</span>  
<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>{  
    Log.i(TAG, <span class="string">"network state changed."</span>);  
    <span class="keyword">if</span> (!isNetworkAvailable(context)) {  
        Toast.makeText(context, <span class="string">"network disconnected!"</span>, <span class="number">0</span>).show();  
    }  
}  

<span class="comment">/** 
 * 网络是否可用 
 *  
 * <span class="doctag">@param</span> context 
 * <span class="doctag">@return</span> 
 */</span>  
<span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isNetworkAvailable</span><span class="params">(Context context)</span> </span>{  
    ConnectivityManager mgr = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);  
    NetworkInfo[] info = mgr.getAllNetworkInfo();  
    <span class="keyword">if</span> (info != <span class="keyword">null</span>) {  
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; info.length; i++) {  
            <span class="keyword">if</span> (info[i].getState() == NetworkInfo.State.CONNECTED) {  
                <span class="keyword">return</span> <span class="keyword">true</span>;  
            }  
        }  
    }  
    <span class="keyword">return</span> <span class="keyword">false</span>;  
}  
</code></pre><p>}<br>再注册一下这个接收者的信息：<br>[html] view plaincopy</p>
<p><receiver android:name=".NetworkStateReceiver"><br>    <intent-filter><br>        <action android:name="android.net.conn.CONNECTIVITY_CHANGE"><br>        <category android:name="android.intent.category.DEFAULT"><br>    </category></action></intent-filter><br></receiver><br>因为在isNetworkAvailable方法中我们使用到了网络状态相关的API，所以需要声明相关的权限才行，下面就是对应的权限声明：<br>[html] view plaincopy</p>
<p><uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"><br>我们可以测试一下，比如关闭WiFi，看看有什么效果。<br>3.电量变化<br>如果我们阅读软件，可能是全屏阅读，这个时候用户就看不到剩余的电量，我们就可以为他们提供电量的信息。要想做到这一点，我们需要接收一条电量变化的广播，然后获取百分比信息，这听上去挺简单的，我们就来实现以下：<br>[java] view plaincopy<br>package com.scott.receiver;  </uses-permission></p>
<p>import android.content.BroadcastReceiver;<br>import android.content.Context;<br>import android.content.Intent;<br>import android.os.BatteryManager;<br>import android.util.Log;  </p>
<p>public class BatteryChangedReceiver extends BroadcastReceiver {  </p>
<pre><code><span class="keyword">private</span> <span class="keyword">static</span> final String TAG = <span class="string">"BatteryChangedReceiver"</span>;  

@<span class="function">Override  
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>{  
    <span class="keyword">int</span> currLevel = intent.getIntExtra(BatteryManager.EXTRA_LEVEL, <span class="number">0</span>);  <span class="comment">//当前电量  </span>
    <span class="keyword">int</span> total = intent.getIntExtra(BatteryManager.EXTRA_SCALE, <span class="number">1</span>);      <span class="comment">//总电量  </span>
    <span class="keyword">int</span> percent = currLevel * <span class="number">100</span> / total;  
    Log.i(TAG, <span class="string">"battery: "</span> + percent + <span class="string">"%"</span>);  
}  
</code></pre><p>}<br>然后再注册一下广播接地址信息就可以了：<br>[html] view plaincopy</p>
<p><receiver android:name=".BatteryChangedReceiver"><br>    <intent-filter><br>        <action android:name="android.intent.action.BATTERY_CHANGED"><br>        <category android:name="android.intent.category.DEFAULT"><br>    </category></action></intent-filter><br></receiver><br>当然，有些时候我们是要立即获取电量的，而不是等电量变化的广播，比如当阅读软件打开时立即显示出电池电量。我们可以按以下方式获取：<br>[java] view plaincopy<br>Intent batteryIntent = getApplicationContext().registerReceiver(null,<br>        new IntentFilter(Intent.ACTION_BATTERY_CHANGED));<br>int currLevel = batteryIntent.getIntExtra(BatteryManager.EXTRA_LEVEL, 0);<br>int total = batteryIntent.getIntExtra(BatteryManager.EXTRA_SCALE, 1);<br>int percent = currLevel * 100 / total;<br>Log.i(“battery”, “battery: “ + percent + “%”);  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/11/21/android广播使用/" data-id="cih8jxxav000384nuctwk5l50" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/11/21/hello-world/" class="article-date">
  <time datetime="2015-11-21T03:44:13.000Z" itemprop="datePublished">2015-11-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/21/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start">Quick Start</h2><h3 id="Create_a_new_post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/11/21/hello-world/" data-id="cih8jxxaq000284nudodvzj9q" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-wode-boke" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/11/21/wode-boke/" class="article-date">
  <time datetime="2015-11-21T03:01:19.000Z" itemprop="datePublished">2015-11-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="#title:_wode_boke">#title: wode boke</h2><p>这是2015年11月，我拥有的了自己的私人博客</p>
<h2 id="序">序</h2><p>###写android的第一篇技术博客</p>
<p>###写java的设计思想</p>
<p>###学习swift</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/11/21/wode-boke/" data-id="cih8jxxae000084nu91j0qhja" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-my-new-post" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/11/21/my-new-post/" class="article-date">
  <time datetime="2015-11-21T02:35:04.000Z" itemprop="datePublished">2015-11-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#我的第一篇博客</p>
<hr>
<p>#狗狗狗</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/11/21/my-new-post/" data-id="cih8jxxam000184nulzl3jlgs" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
  
</section>
        
          <aside id="sidebar">
  
    
  
    
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a><span class="archive-list-count">4</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2015/11/21/android广播使用/">android广播的使用</a>
          </li>
        
          <li>
            <a href="/2015/11/21/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2015/11/21/wode-boke/">(no title)</a>
          </li>
        
          <li>
            <a href="/2015/11/21/my-new-post/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 JIANG HAO<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>