<!doctype html>
<html class="theme-next   use-motion ">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.4.5.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.2" />






<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="jianghao's blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="jianghao's blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="jianghao's blog">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'post',
    motion: true
  };
</script>

  <title> jianghao's blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  






  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">jianghao's blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          
  <section id="posts" class="posts-expand">

    

    
    

    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/01/12/java中静态方、实例方法、final方法的区别/" itemprop="url">
                  java中静态方法、实例方法、final方法的区别
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-01-12T20:18:38+08:00" content="2016-01-12">
              2016-01-12
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/01/12/java中静态方、实例方法、final方法的区别/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/01/12/java中静态方、实例方法、final方法的区别/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h3 id="1-final方法：">1.final方法：</h3><p>将方法声明为final那有两个原因<br>第一就是说明你已经知道这个方法提供的功能已经满足你要求，不需要进行扩展，并且也不允许任何从此类继承的类来覆写这个方法，但是继承仍然可以继承这个方法，也就是说可以直接使用。</p>
<p>第二就是允许编译器将所有对此方法的调用转化为inline调用的机制，它会使你在调用final方法时，直接将方法主体插入到调用处，而不是进行例行的方法调用，例如保存断点，压栈等，这样可能会使你的程序效率有所提高，然而当你的方法主体非常庞大时，或你在多处调用此方法，那么你的调用主体代码便会迅速膨胀，可能反而会影响效率，所以你要慎用final进行方法定义。</p>
<h3 id="2-静态方法和实例方法">2.静态方法和实例方法</h3><p>在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</p>
<p>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。</p>
<p>下面几个例子展示了这一区别：</p>
<p>1.调用静态方法的示例</p>
  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> public class hasStaticMethod&#123;&#10;//&#23450;&#20041;&#19968;&#20010;&#38745;&#24577;&#26041;&#27861;&#10; public static void callMe()&#123;&#10;&#12288;&#12288;System.out.println(&#34;This is a static method.&#34;);&#10; &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>   2.使用两种方式来调用静态方法</p>
   <figure class="highlight"><figcaption><span>class invokeStaticMethod&#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#12288;&#12288;public static void main(String args[])&#123;&#10;&#12288;&#12288;hasStaticMethod.callMe();  //&#19981;&#21019;&#24314;&#23545;&#35937;&#65292;&#30452;&#25509;&#35843;&#29992;&#38745;&#24577;&#26041;&#27861;    &#10;&#12288;&#12288;hasStaticMethod oa = new hasStaticMethod();   //&#21019;&#24314;&#19968;&#20010;&#23545;&#35937;&#10;&#12288;&#12288;oa.callMe();      //&#21033;&#29992;&#23545;&#35937;&#26469;&#35843;&#29992;&#38745;&#24577;&#26041;&#27861;&#10;&#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>3、静态方法访问成员变量示例。<br> <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class accessMember&#123;&#10;private static int sa; //&#23450;&#20041;&#19968;&#20010;&#38745;&#24577;&#25104;&#21592;&#21464;&#37327;&#10;private int ia;  //&#23450;&#20041;&#19968;&#20010;&#23454;&#20363;&#25104;&#21592;&#21464;&#37327;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面定义一个静态方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">statMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">　　<span class="keyword">int</span> i = <span class="number">0</span>;    <span class="comment">//正确，可以有自己的局部变量sa = 10;   </span></span><br><span class="line">　　<span class="comment">//正确，静态方法可以使用静态变量</span></span><br><span class="line">　　otherStat();  </span><br><span class="line">　　<span class="comment">//正确，可以调用静态方法</span></span><br><span class="line">　　ia = <span class="number">20</span>;   <span class="comment">//错误，不能使用实例变量</span></span><br><span class="line">　　insMethod();  <span class="comment">//错误，不能调用实例方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">otherStat</span><span class="params">()</span></span>&#123;&#125; </span><br><span class="line"><span class="comment">//下面定义一个实例方法 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">insMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">　　<span class="keyword">int</span> i = <span class="number">0</span>;    <span class="comment">//正确，可以有自己的局部变量</span></span><br><span class="line">　　sa = <span class="number">15</span>;    <span class="comment">//正确，可以使用静态变量</span></span><br><span class="line">　　ia = <span class="number">30</span>;    <span class="comment">//正确，可以使用实例变量</span></span><br><span class="line">　　statMethod();   <span class="comment">//正确，可以调用静态方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本例其实可以概括成一句话：静态方法只能访问静态成员，实例方法可以访问静态和实例成员。之所以不允许静态方法访问实例成员变量，是因为实例成员变量是属于某个对象的，而静态方法在执行时，并不一定存在对象。同样，因为实例方法可以访问实例成员变量，如果允许静态方法调用实例方法，将间接地允许它使用实例成员变量，所以它也不能调用实例方法。基于同样的道理，静态方法中也不能使用关键字this。</p>
<p>main()方法是一个典型的静态方法，它同样遵循一般静态方法的规则，所以它可以由系统在创建对象之前就调用。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/01/07/android-service断点续传/" itemprop="url">
                  未命名
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-01-07T16:45:01+08:00" content="2016-01-07">
              2016-01-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/01/07/android-service断点续传/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/01/07/android-service断点续传/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h3 id="获得网络文件的长度">获得网络文件的长度</h3><h3 id="在本地创建一个文件，设置其长度">在本地创建一个文件，设置其长度</h3><h3 id="从数据库中获得上次下载的进度">从数据库中获得上次下载的进度</h3><h3 id="从上次位置下载数据，同时保存进度到数据库">从上次位置下载数据，同时保存进度到数据库</h3><h3 id="将下载的进度回传给activity">将下载的进度回传给activity</h3><h3 id="下载完成后删除下载信息">下载完成后删除下载信息</h3>
            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/01/06/android广播使用/" itemprop="url">
                  android广播的使用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-01-06T09:44:13+08:00" content="2016-01-06">
              2016-01-06
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/01/06/android广播使用/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/01/06/android广播使用/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <hr>
<p>BroadcastReceiver也就是“广播接收者”的意思，顾名思义，它就是用来接收来自系统和应用中的广播。<br>在Android系统中，广播体现在方方面面，例如当开机完成后系统会产生一条广播，接收到这条广播就能实现开机启动服务的功能；当网络状态改变时系统会产生一条广播，接收到这条广播就能及时地做出提示和保存数据等操作；当电池电量改变时，系统会产生一条广播，接收到这条广播就能在电量低时告知用户及时保存进度，等等。<br>Android中的广播机制设计的非常出色，很多事情原本需要开发者亲自操作的，现在只需等待广播告知自己就可以了，大大减少了开发的工作量和开发周期。而作为应用开发者，就需要数练掌握Android系统提供的一个开发利器，那就是BroadcastReceiver。下面我们就对BroadcastReceiver逐一地分析和演练，了解和掌握它的各种功能和用法。</p>
<p>.首先，我们来演示一下创建一个BroadcastReceiver，并让这个BroadcastReceiver能够根据我们的需要来运行。要创建自己的BroadcastReceiver对象，我们需要继承android.content.BroadcastReceiver，并实现其onReceive方法。下面我们就创建一个名为MyReceiver广播接收者：<br>package com.scott.receiver;  </p>
<p>import android.content.BroadcastReceiver;<br>import android.content.Context;<br>import android.content.Intent;<br>import android.util.Log;  </p>
<p>public class MyReceiver extends BroadcastReceiver {  </p>
<pre><code><span class="keyword">private</span> static final <span class="built_in">String</span> <span class="built_in">TAG</span> = <span class="string">"MyReceiver"</span>;  

@Override  
<span class="keyword">public</span> <span class="literal">void</span> onReceive(Context context, Intent intent) {  
    <span class="built_in">String</span> msg = intent<span class="built_in">.</span>getStringExtra(<span class="string">"msg"</span>);  
    <span class="keyword">Log</span><span class="built_in">.</span>i(<span class="built_in">TAG</span>, msg);  
}  
</code></pre><p>}<br>.在onReceive方法内，我们可以获取随广播而来的Intent中的数据，这非常重要，就像无线电一样，包含很多有用的信息。<br>在创建完我们的BroadcastReceiver之后，还不能够使它进入工作状态，我们需要为它注册一个指定的广播地址。没有注册广播地址的BroadcastReceiver就像一个缺少选台按钮的收音机，虽然功能俱备，但也无法收到电台的信号。下面我们就来介绍一下如何为BroadcastReceiver注册广播地址。</p>
<p>##静态注册<br>.静态注册是在AndroidManifest.xml文件中配置的，我们就来为MyReceiver注册一个广播地址：<br>[html] view plaincopy</p>
<p><receiver android:name=".MyReceiver"><br>            <intent-filter><br>                <action android:name="android.intent.action.MY_BROADCAST"><br>                <category android:name="android.intent.category.DEFAULT"><br>            </category></action></intent-filter><br>        </receiver><br>配置了以上信息之后，只要是android.intent.action.MY_BROADCAST这个地址的广播，MyReceiver都能够接收的到。注意，这种方式的注册是常驻型的，也就是说当应用关闭后，如果有广播信息传来，MyReceiver也会被系统调用而自动运行。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/01/06/java享元模式/" itemprop="url">
                  java享元模式（Flyweight）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-01-06T09:19:23+08:00" content="2016-01-06">
              2016-01-06
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/01/06/java享元模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/01/06/java享元模式/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <hr>
<p>享元模式以共享的方式高效地支持大量细粒度对象。<br>在面向对象的程序设计语言来看在面向对象的程序设计语言看来，一切事务都被描述成对象（Object）。对象拥有状态（属性）和行为（方法），我们将具有相同行为的对象抽象为类（Class），类可以被看作只保留行为的对象模板，类可以在运行时被重新赋予状态数据从而形成了对象。</p>
<p>在运行时，对象占用一定的内存空间用来存储状态数据。如果不作特殊的处理，尽管是由同一个类生成的两个对象，而且这两个对象的的状态数据完 全相同，但在内存中还是会占用两份空间，这样的情况对于程序的功能也许并没有影响，但如果把状态相同的同一类对象在内存中进行合并，必然会大大减少存储空间的浪费。</p>
<p>举一个现实中的例子，某淘宝店经营一款畅销女式皮鞋，每天需要处理大量的订单信息，在订单中需要注明客户购买的皮鞋信息，我们将皮鞋产品抽象出来：</p>
<pre><code> class Shoe{ 
 <span class="keyword">String</span> <span class="built_in">color</span>;<span class="comment">//颜色 </span>
 <span class="built_in">int</span> <span class="built_in">size</span>;<span class="comment">//尺寸 </span>
 <span class="keyword">String</span> position;<span class="comment">//库存位置 </span>

 <span class="keyword">public</span> <span class="keyword">String</span> getColor() { 
     <span class="keyword">return</span> <span class="built_in">color</span>; 
 } 

 <span class="keyword">public</span> <span class="keyword">void</span> setColor(<span class="keyword">String</span> <span class="built_in">color</span>) { 
     <span class="keyword">this</span>.<span class="built_in">color</span> = <span class="built_in">color</span>; 
 } 

 <span class="keyword">public</span> <span class="built_in">int</span> getSize() { 
     <span class="keyword">return</span> <span class="built_in">size</span>; 
 } 

 <span class="keyword">public</span> <span class="keyword">void</span> setSize(<span class="built_in">int</span> <span class="built_in">size</span>) { 
     <span class="keyword">this</span>.<span class="built_in">size</span> = <span class="built_in">size</span>; 
 } 

 <span class="keyword">public</span> <span class="keyword">String</span> getPosition() { 
     <span class="keyword">return</span> position; 
 } 

 <span class="keyword">public</span> <span class="keyword">void</span> setPosition(<span class="keyword">String</span> position) { 
     <span class="keyword">this</span>.position = position; 
 } 

}
</code></pre><p>正如上面的代码所描述，皮鞋分为颜色、尺寸和库存位置三项状态数据。其中颜色和尺寸为皮鞋的自然状态，我们称之为对象内部状态，这些状态数据只与对象本身有关，不随外界环境的改变而发生变化。再来看库存位置，我们将这个状态称为对象的外部状态，外部状态与对象本身无必然关系，外部状态总是因为外界环境的改变而变化，也就是说外部状态是由外界环境来决定的。在本例中，皮鞋今天放在A仓库，明天可能放在B仓库，但无论存放在哪个仓库，同一只皮鞋就是同一只皮鞋，它的颜色和尺寸不会随着存放位置的不同而发生变化。</p>
<p> 享元模式的核心思想就是将内部状态相同的对象在存储时进行缓存。也就是说同一颜色同一尺寸的皮鞋，我们在内存中只保留一份实例，在访问对象时，我们访问的其实是对象缓存的版本，而不是每次都重新生成对象。</p>
<p>享元模式仍然允许对象具有外部属性，由于我们访问的始终是对象缓存的版本，所以我们在使用对象前，必须将外部状态重新注入对象。由于享元模式禁止生成新的对象，所以在使用享元模式时，通常伴随着工厂方法的应用。我们来看下面的例子：</p>
<pre><code> class ShoeFactory { 

Collection&lt;Shoe&gt; shoes = <span class="keyword">new</span> ArrayList&lt;Shoe&gt;(); 

Shoe getSheo(<span class="keyword">String</span> <span class="built_in">color</span>, <span class="built_in">int</span> <span class="built_in">size</span>, <span class="keyword">String</span> position)             

{ 
    <span class="comment">//首先在缓存中查找对象 </span>
    <span class="keyword">for</span> (Shoe shoe : shoes) { 
        <span class="keyword">if</span> (shoe.getColor() == <span class="built_in">color</span> &amp;&amp;shoe.getSize()== <span class="built_in">size</span>) { 
            <span class="comment">//在缓存中命中对象后还原对象的外部属性 </span>
            shoe.setPosition(position); 
            <span class="keyword">return</span> shoe; 
        } 
    } 
    <span class="comment">//如果缓存未命中则新建对象并加入缓存 </span>
    Shoe shoe = <span class="keyword">new</span> Shoe(); 
    shoe.setColor(<span class="built_in">color</span>); 
    shoe.setSize(<span class="built_in">size</span>); 
    shoe.setPosition(position); 
    shoes.<span class="built_in">add</span>(shoe); 
    <span class="keyword">return</span> shoe; 
    } 
 } 
</code></pre><p>通过ShoeFactory工厂，我们每次拿到的皮鞋都是缓存的版本，如果缓存中没有我们需要的对象，则新创建对象然后加入缓存中。注意上例中对象的外部属性position是如何注回对象的。</p>
<p>当我们在自己的业务场景中应用享元模式时，一定要注意分清对象的内部状态和外部状态，享元模式强调缓存的版本只能包含对象的内部状态。</p>
<p>事实上，Java中的String和Integer类都是享元模式的应用的例子，String类内部对所有的字符串对象进行缓存，相同的字符串在内存中只会保留一个版本。类似的，Integer类在内部对小于255的整数也进行了缓存。</p>
<p>享元模式在企业级架构设计中应用的例子比比皆是，现代大型企业级应用中不可或缺的缓存体系也正是在享元模式的基础上逐步完善和发展起来的。  </p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/12/22/java中-byteByffer中的clear、flip、rewind/" itemprop="url">
                  java中 byteByffer中的clear、flip、rewind
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-12-22T15:17:46+08:00" content="2015-12-22">
              2015-12-22
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/12/22/java中-byteByffer中的clear、flip、rewind/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/12/22/java中-byteByffer中的clear、flip、rewind/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <hr>
<h3 id="对缓冲区的读写操作首先要知道缓冲区的下限、上限和当前位置。下面这些变量的值对Buffer类中的某些操作有着至关重要的作用：">对缓冲区的读写操作首先要知道缓冲区的下限、上限和当前位置。下面这些变量的值对Buffer类中的某些操作有着至关重要的作用：</h3><h2 id="limit：所有对Buffer读写操作都会以limit变量的值作为上限。">limit：所有对Buffer读写操作都会以limit变量的值作为上限。</h2><h2 id="position：代表对缓冲区进行读写时，当前游标的位置。">position：代表对缓冲区进行读写时，当前游标的位置。</h2><h2 id="capacity：代表缓冲区的最大容量（一般新建一个缓冲区的时候，limit的值和capacity的值默认是相等的）。">capacity：代表缓冲区的最大容量（一般新建一个缓冲区的时候，limit的值和capacity的值默认是相等的）。</h2><h3 id="flip、rewind、clear这三个方法便是用来设置这些值的。">flip、rewind、clear这三个方法便是用来设置这些值的。</h3><h2 id="clear方法">clear方法</h2><p>public final Buffer clear()<br>{<br>    position = 0; //重置当前读写位置<br>    limit = capacity;<br>    mark = -1;  //取消标记<br>    return this;<br>}<br>clear方法将缓冲区清空，一般是在重新写缓冲区时调用。</p>
<h2 id="flip方法">flip方法</h2><p>public final Buffer flip() {<br> limit = position;<br> position = 0;<br> mark = -1;<br> return this;<br>}<br>反转缓冲区。首先将限制设置为当前位置，然后将位置设置为 0。如果已定义了标记，则丢弃该标记。 常与compact方法一起使用。通常情况下，在准备从缓冲区中读取数据时调用flip方法。</p>
<h2 id="rewind方法">rewind方法</h2><p>public final Buffer rewind() {<br> position = 0;<br> mark = -1;<br>return this;<br>}</p>
<h2 id="以上三种方法均使用final修饰，java-nio-Buffer的所有子类均使用同一种flip、clear和rewind机制。">以上三种方法均使用final修饰，java.nio.Buffer的所有子类均使用同一种flip、clear和rewind机制。</h2>
            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/12/14/链表和数组的区别/" itemprop="url">
                  链表和数组
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-12-14T22:37:49+08:00" content="2015-12-14">
              2015-12-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/12/14/链表和数组的区别/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/12/14/链表和数组的区别/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <hr>
<p>##链表和数组的区别</p>
<p>1）数组在内存中是逐个存放的，也就是说倘若数组的第一个元素在地址A,则数组第二个元素就在地址A+1。</p>
<p>而链表则不是，链表每个节点没有相对固定的位置关系。某个节点在地址A其后的节点不一定是A+1,而在内存的其他空闲区域，呈现一种随机的状态。</p>
<p>2）数组一旦显式的被申明后，其大小就固定了，不能动态进行扩充。而链表则可以，可以动态生成节点并且添加到已有的链表后面。</p>
<p>3）链表灵活，但是空间和时间额外耗费较大；数组大小固定，元素位置固定，但是操作不灵活，且容易浪费空间，但是时间耗费较小，尤其是元素变化不大的时候效率很高。双向链表比单向的更灵活，但是空间耗费也更大</p>
<p>。。。。。</p>
<p>链表的特性是在中间任意位置添加删除元素的都非常的快，不需要移动其它的元素。链表顾名思义，要把各个元素链接起来才算撒。<br>通常链表每一个元素都要保存一个指向下一个元素的指针（单链表）。双链表的化每个元素即要保存到下一个元素的指针，还要保存一个上一个元素的指针。循环链表则把最后一个元素中保存下一个元素指针指向第一个元素。数组是一组具有相同类型和名称的变量的集合。这些变量称为数组的元素,每个数组元素都有一个编号,这个编号叫做下标,我们可以通过下标来区别这些元素。数组元素的个数有时也称之为数组的长度。 </p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/12/05/intent传递数据量问题/" itemprop="url">
                  intent传递数据量问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-12-05T10:34:27+08:00" content="2015-12-05">
              2015-12-05
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/12/05/intent传递数据量问题/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/12/05/intent传递数据量问题/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <hr>
<h2 id="传输超过1M的数据量会crash">传输超过1M的数据量会crash</h2><p>在Activity或者组件之前传递信息时，一般采用intent绑定bundle的方式传值，但在使用过程中需要注意的是不要用bundle传递大容量数据：</p>
<p>在做项目的过程中，需要将听写界面的听写结果信息传递到听写记录界面供显示用，但是由于传递的数据量过大导致程序ANR，甚至直接报异常（传递的信息里面有bitmap转换成的byte数组、每一个词组的拼音、词语、语音信息），经过分析发现是由于bundle不能传递大容量的数据信息，在stackoverflow里面查阅发现有同行遇到类似的问题：</p>
<p>（1）“The size limit of Intent is still pretty low in Jelly Bean, which is somewhat lower than 1MB (around 90K), so you should always be cautious about your data length, even if your application targets only latest Android versions.”</p>
<p>（2）“As per my experience (sometime ago), you are able to put up to 1MB of data in a Bundleencapsulated inside Intent. I think, this restriction was valid up till Froyo or GingerBread.”</p>
<p>所以在通过bundle传递数据时只能传递较小的数据信息，对于在不同组件之间需要传递大容量数据的情况时，有几种替代方式可以解决不能用bundle传递这些数据的问题：</p>
<h2 id="方法一：">方法一：</h2><p>将需要传递的数据写在临时文件或者数据库中，再跳转到另外一个组件的时候再去读取这些数据信息，这种处理方式会由于读写文件较为耗时导致程序运行效率较低；</p>
<h2 id="方法二：">方法二：</h2><p>将需要传递的数据信息封装在一个静态的类中（注意当前组件和要跳转到的组件必须属于同一个进程，因为进程之间才能够共享数据），在当前组件中为类设置内容，然后再跳转到的组件中去取，这种处理方式效率很高，但是会破坏程序的独立性。</p>
<p>具体采用哪种替代方式取决于具体的情况，建议采取第二种处理方式，因为这样会大大提高程序的运行效率，至于程序的独立性，看你怎么去封装这个类了。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    

  </section>

  


        </div>

        


        

      </div>

      
        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/images/avatar.png" alt="JIANG HAO" itemprop="image"/>
          <p class="site-author-name" itemprop="name">JIANG HAO</p>
        </div>
        <p class="site-description motion-element" itemprop="description"></p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">7</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">4</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">9</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


      
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JIANG HAO</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

本站总访问量 <span id="busuanzi_value_site_pv"></span> &nbsp&nbsp&nbsp
您是第<span id="busuanzi_value_site_uv"></span>个来到的小伙伴



      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
    

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"jianghaoplus"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
    
     


    
  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.2"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.2"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
<script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

<script type="text/javascript" src="/js/motion.js?v=0.4.5.2" id="motion.global"></script>


  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  

  <script type="text/javascript" src="/js/bootstrap.js"></script>

  
  

  
  

</body>
</html>
